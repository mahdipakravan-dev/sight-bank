import {
  gsapWithCSS
} from "./chunk-DMVRRVEU.js";
import {
  require_jsx_runtime
} from "./chunk-LHQHKL4P.js";
import {
  require_react
} from "./chunk-HZAPEE6N.js";
import {
  __toESM
} from "./chunk-EQCVQC35.js";

// node_modules/.pnpm/@bsmnt+scrollytelling@0.3.3_@types+react-dom@19.1.6_@types+react@19.1.7__@types+react@1_315ee060a017125d328efbe9c7976584/node_modules/@bsmnt/scrollytelling/dist/chunk-WGDYDWJO.mjs
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function getTweenTarget({
  targetContainer,
  ref
}) {
  if (targetContainer.target) {
    if (targetContainer.target && typeof targetContainer.target === "object" && "current" in targetContainer.target) {
      return targetContainer.target.current;
    } else {
      return targetContainer.target;
    }
  } else if (ref) {
    return ref.current;
  } else {
    return null;
  }
}
function buildDeclarativeTween(_a) {
  var _b = _a, {
    op,
    id,
    target,
    duration,
    paused
  } = _b, timelineAndPosition = __objRest(_b, [
    "op",
    "id",
    "target",
    "duration",
    "paused"
  ]);
  var _a2;
  const data = {
    id,
    type: "animation",
    rootId: (_a2 = timelineAndPosition.timeline) == null ? void 0 : _a2.data.id,
    isScrollytellingTween: true
  };
  if ("to" in op) {
    if (timelineAndPosition.timeline) {
      timelineAndPosition.timeline.to(
        target,
        __spreadProps(__spreadValues({}, op.to), {
          id,
          duration,
          paused,
          data
        }),
        timelineAndPosition.position
      );
    } else {
      gsapWithCSS.to(target, __spreadProps(__spreadValues({}, op.to), { id, duration, paused }));
    }
  } else if ("from" in op) {
    if (timelineAndPosition.timeline) {
      timelineAndPosition.timeline.from(
        target,
        __spreadProps(__spreadValues({}, op.from), { id, duration, paused, data }),
        timelineAndPosition.position
      );
    } else {
      gsapWithCSS.from(target, __spreadProps(__spreadValues({}, op.from), { id, duration, paused }));
    }
  } else if ("fromTo" in op) {
    if (timelineAndPosition.timeline) {
      timelineAndPosition.timeline.fromTo(
        target,
        __spreadValues({}, op.fromTo[0]),
        __spreadProps(__spreadValues({}, op.fromTo[1]), { id, duration, paused, data }),
        timelineAndPosition.position
      );
    } else {
      gsapWithCSS.fromTo(
        target,
        __spreadValues({}, op.fromTo[0]),
        __spreadProps(__spreadValues({}, op.fromTo[1]), { id, duration, paused })
      );
    }
  } else
    throw new Error("Invalid TweenOp");
  return () => {
    var _a3;
    (_a3 = gsapWithCSS.getById(id)) == null ? void 0 : _a3.revert();
  };
}
var clsx = (...classes) => {
  return classes.filter(Boolean).join(" ");
};
var isDev = true;
var Emitter = class {
  constructor() {
    this.events = {};
  }
  emit(event, ...args) {
    var _a;
    const callbacks = this.events[event] || [];
    for (let i = 0, length = callbacks.length; i < length; i++) {
      (_a = callbacks[i]) == null ? void 0 : _a.call(callbacks, ...args);
    }
  }
  on(event, cb) {
    var _a;
    ((_a = this.events[event]) == null ? void 0 : _a.push(cb)) || (this.events[event] = [cb]);
    return () => {
      this.off(event, cb);
    };
  }
  off(event, cb) {
    var _a, _b;
    this.events[event] = (_b = (_a = this.events[event]) == null ? void 0 : _a.filter((i) => cb !== i)) != null ? _b : [];
  }
  destroy() {
    this.events = {};
  }
};
var internalEventEmmiter = new Emitter();

// node_modules/.pnpm/@radix-ui+react-slot@1.2.3_@types+react@19.1.7_react@19.1.0/node_modules/@radix-ui/react-slot/dist/index.mjs
var React2 = __toESM(require_react(), 1);

// node_modules/.pnpm/@radix-ui+react-compose-refs@1.1.2_@types+react@19.1.7_react@19.1.0/node_modules/@radix-ui/react-compose-refs/dist/index.mjs
var React = __toESM(require_react(), 1);
function setRef(ref, value) {
  if (typeof ref === "function") {
    return ref(value);
  } else if (ref !== null && ref !== void 0) {
    ref.current = value;
  }
}
function composeRefs(...refs) {
  return (node) => {
    let hasCleanup = false;
    const cleanups = refs.map((ref) => {
      const cleanup = setRef(ref, node);
      if (!hasCleanup && typeof cleanup == "function") {
        hasCleanup = true;
      }
      return cleanup;
    });
    if (hasCleanup) {
      return () => {
        for (let i = 0; i < cleanups.length; i++) {
          const cleanup = cleanups[i];
          if (typeof cleanup == "function") {
            cleanup();
          } else {
            setRef(refs[i], null);
          }
        }
      };
    }
  };
}

// node_modules/.pnpm/@radix-ui+react-slot@1.2.3_@types+react@19.1.7_react@19.1.0/node_modules/@radix-ui/react-slot/dist/index.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
function createSlot(ownerName) {
  const SlotClone = createSlotClone(ownerName);
  const Slot2 = React2.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    const childrenArray = React2.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (React2.Children.count(newElement) > 1) return React2.Children.only(null);
          return React2.isValidElement(newElement) ? newElement.props.children : null;
        } else {
          return child;
        }
      });
      return (0, import_jsx_runtime.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children: React2.isValidElement(newElement) ? React2.cloneElement(newElement, void 0, newChildren) : null });
    }
    return (0, import_jsx_runtime.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children });
  });
  Slot2.displayName = `${ownerName}.Slot`;
  return Slot2;
}
var Slot = createSlot("Slot");
function createSlotClone(ownerName) {
  const SlotClone = React2.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    if (React2.isValidElement(children)) {
      const childrenRef = getElementRef(children);
      const props2 = mergeProps(slotProps, children.props);
      if (children.type !== React2.Fragment) {
        props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
      }
      return React2.cloneElement(children, props2);
    }
    return React2.Children.count(children) > 1 ? React2.Children.only(null) : null;
  });
  SlotClone.displayName = `${ownerName}.SlotClone`;
  return SlotClone;
}
var SLOTTABLE_IDENTIFIER = Symbol("radix.slottable");
function createSlottable(ownerName) {
  const Slottable2 = ({ children }) => {
    return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children });
  };
  Slottable2.displayName = `${ownerName}.Slottable`;
  Slottable2.__radixId = SLOTTABLE_IDENTIFIER;
  return Slottable2;
}
var Slottable = createSlottable("Slottable");
function isSlottable(child) {
  return React2.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER;
}
function mergeProps(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          const result = childPropValue(...args);
          slotPropValue(...args);
          return result;
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef(element) {
  var _a, _b;
  let getter = (_a = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

export {
  __spreadValues,
  __spreadProps,
  __objRest,
  __async,
  getTweenTarget,
  buildDeclarativeTween,
  clsx,
  isDev,
  internalEventEmmiter,
  createSlot,
  Slot
};
//# sourceMappingURL=chunk-HBGJWCCJ.js.map
