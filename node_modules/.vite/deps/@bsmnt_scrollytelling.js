import {
  ScrollTrigger
} from "./chunk-JBBSTYDB.js";
import {
  Slot,
  __async,
  __objRest,
  __spreadProps,
  __spreadValues,
  buildDeclarativeTween,
  getTweenTarget,
  internalEventEmmiter,
  isDev
} from "./chunk-HBGJWCCJ.js";
import {
  gsapWithCSS
} from "./chunk-DMVRRVEU.js";
import {
  require_jsx_runtime
} from "./chunk-LHQHKL4P.js";
import {
  require_react
} from "./chunk-HZAPEE6N.js";
import {
  __toESM
} from "./chunk-EQCVQC35.js";

// node_modules/.pnpm/@bsmnt+scrollytelling@0.3.3_@types+react-dom@19.1.6_@types+react@19.1.7__@types+react@1_315ee060a017125d328efbe9c7976584/node_modules/@bsmnt/scrollytelling/dist/index.mjs
var React7 = __toESM(require_react(), 1);
var import_react = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var ScrollytellingContext = React7.createContext(void 0);
var useScrollytelling = () => {
  const scrollytelling = React7.useContext(ScrollytellingContext);
  if (!scrollytelling) {
    throw new Error(
      "useScrollytelling must be used within a Scrollytelling.Root"
    );
  }
  return scrollytelling;
};
var ScrollytellingDispatchersContext = React7.createContext(void 0);
var useDispatcher = () => {
  const dispatcher = React7.useContext(ScrollytellingDispatchersContext);
  if (!dispatcher) {
    throw new Error("useDispatcher must be used within a ScrollytellingRoot");
  }
  return dispatcher;
};
function Animation({
  tween,
  children,
  disabled = false
}) {
  const ref = React7.useRef(null);
  const id = React7.useId();
  const { timeline } = useScrollytelling();
  const { getTimelineSpace } = useDispatcher();
  React7.useEffect(() => {
    if (!timeline || !tween || disabled)
      return;
    const addTweenToTimeline = (tween2) => {
      const tweenTarget = getTweenTarget({
        targetContainer: "target" in tween2 ? tween2 : {},
        ref
      });
      if (tweenTarget) {
        const timelineSpace = getTimelineSpace({
          start: tween2.start,
          end: tween2.end
        });
        if (!timelineSpace)
          return;
        const cleanup = buildDeclarativeTween({
          id,
          timeline,
          op: tween2,
          target: tweenTarget,
          duration: timelineSpace.duration,
          position: timelineSpace.position
        });
        return () => {
          cleanup();
          timelineSpace.cleanup();
        };
      } else
        return () => void 0;
    };
    if (Array.isArray(tween)) {
      const cleanupTweens = tween.map((tween2) => {
        const cleanup = addTweenToTimeline(tween2);
        return cleanup;
      });
      return () => {
        cleanupTweens.forEach((cleanup) => cleanup == null ? void 0 : cleanup());
      };
    } else {
      const cleanup = addTweenToTimeline(tween);
      return () => {
        cleanup == null ? void 0 : cleanup();
      };
    }
  }, [getTimelineSpace, id, tween, timeline, disabled]);
  if (children) {
    return (0, import_jsx_runtime.jsx)(Slot, { ref, children });
  }
  return null;
}
var Parallax = ({
  children,
  tween,
  disabled = false
}) => {
  if (!tween.movementY && !tween.movementX) {
    throw new Error(
      "At least one of movementY and movementX is required in Parallax component."
    );
  }
  return (0, import_jsx_runtime.jsx)(
    Animation,
    {
      disabled,
      tween: __spreadProps(__spreadValues({}, tween), {
        fromTo: [
          {
            y: tween.movementY ? -1 * tween.movementY.value + tween.movementY.unit : void 0,
            x: tween.movementX ? -1 * tween.movementX.value + tween.movementX.unit : void 0
          },
          {
            y: tween.movementY ? tween.movementY.value + tween.movementY.unit : void 0,
            x: tween.movementX ? tween.movementX.value + tween.movementX.unit : void 0,
            ease: "linear"
          }
        ]
      }),
      children
    }
  );
};
var Pin = React7.forwardRef(
  ({
    childClassName,
    childHeight,
    children,
    pinSpacerClassName,
    pinSpacerHeight,
    top = 0
  }, ref) => {
    if (!childHeight || !pinSpacerHeight) {
      throw new Error(
        "childHeight and pinSpacerHeight are required in Pin component."
      );
    }
    return (0, import_jsx_runtime.jsx)(
      "div",
      {
        className: pinSpacerClassName,
        ref,
        style: { height: pinSpacerHeight },
        children: (0, import_jsx_runtime.jsx)(
          "div",
          {
            className: childClassName,
            style: { height: childHeight, position: "sticky", top },
            children
          }
        )
      }
    );
  }
);
Pin.displayName = "Pin";
var useIsoLayoutEffect = typeof document === "undefined" ? import_react.useEffect : import_react.useLayoutEffect;
var RegisterGsapPlugins = ({ plugins }) => {
  useIsoLayoutEffect(() => {
    gsapWithCSS.registerPlugin(...plugins);
  }, []);
  return null;
};
function Waypoint({
  tween,
  children,
  at,
  label,
  onCall,
  onReverseCall,
  disabled = false
}) {
  const ref = React7.useRef(null);
  const id = React7.useId();
  const lastStateRef = React7.useRef(
    "idle"
  );
  const { timeline } = useScrollytelling();
  const { getTimelineSpace } = useDispatcher();
  const waypointLabel = label != null ? label : `label-${id}`;
  React7.useEffect(() => {
    if (!timeline || disabled)
      return;
    let cleanupTween = void 0;
    let generatedTween = void 0;
    if (tween) {
      const _a = tween, { duration } = _a, op = __objRest(_a, ["duration"]);
      const tweenTarget = getTweenTarget({ targetContainer: tween, ref });
      cleanupTween = buildDeclarativeTween({
        id: id + "-tween",
        op,
        duration,
        target: tweenTarget,
        paused: true
      });
      generatedTween = gsapWithCSS.getById(id + "-tween");
    }
    const space = getTimelineSpace({ start: at, end: at });
    if (!space)
      return;
    const newSet = gsapWithCSS.set(
      {},
      {
        id,
        paused: true,
        data: {
          id,
          type: "waypoint",
          rootId: timeline.data.id,
          isScrollytellingTween: true,
          label: waypointLabel
        }
      }
    );
    if (lastStateRef.current === "complete") {
      newSet.play();
    }
    newSet.vars.onComplete = () => {
      var _a2, _b;
      lastStateRef.current = "complete";
      (_b = (_a2 = newSet.data)._internalOnCall) == null ? void 0 : _b.call(_a2);
      onCall == null ? void 0 : onCall();
      generatedTween == null ? void 0 : generatedTween.play();
    };
    newSet.vars.onReverseComplete = () => {
      var _a2, _b;
      lastStateRef.current = "reverse-complete";
      (_b = (_a2 = newSet.data)._internalOnReverseCall) == null ? void 0 : _b.call(_a2);
      onReverseCall == null ? void 0 : onReverseCall();
      if (!(tween == null ? void 0 : tween.forwards)) {
        generatedTween == null ? void 0 : generatedTween.reverse();
      }
    };
    timeline.add(newSet, space.position);
    newSet.play();
    timeline.addLabel(waypointLabel, space.position);
    return () => {
      var _a2;
      (_a2 = gsapWithCSS.getById(id)) == null ? void 0 : _a2.revert();
      cleanupTween == null ? void 0 : cleanupTween();
      timeline.removeLabel(waypointLabel);
      space.cleanup();
    };
  }, [at, disabled, getTimelineSpace, id, onCall, onReverseCall, timeline, tween, waypointLabel]);
  if (children) {
    return (0, import_jsx_runtime.jsx)(Slot, { ref, children });
  }
  return null;
}
function Stagger({
  children,
  overlap = 0,
  tween,
  disabled = false
}) {
  const isTweenWithTarget = "target" in tween;
  const targetLength = isTweenWithTarget && Array.isArray(tween.target) ? tween.target.length : children == null ? void 0 : children.length;
  const timeline = React7.useMemo(() => {
    if ((tween == null ? void 0 : tween.start) === void 0 || (tween == null ? void 0 : tween.end) === void 0) {
      if (isDev) {
        throw new Error("Stagger needs a start and end value");
      } else {
        console.warn("Stagger needs a start and end value");
      }
      return [];
    }
    return getStaggeredTimeline({
      start: tween == null ? void 0 : tween.start,
      end: tween == null ? void 0 : tween.end,
      chunks: targetLength,
      overlap
    });
  }, [targetLength, overlap, tween == null ? void 0 : tween.end, tween == null ? void 0 : tween.start]);
  if (children) {
    return children.map((child, i) => {
      const currTween = timeline[i];
      if (!currTween) {
        return null;
      }
      return (0, import_jsx_runtime.jsx)(
        Animation,
        {
          tween: __spreadProps(__spreadValues({}, tween), {
            start: currTween.start,
            end: currTween.end
          }),
          disabled,
          children: child
        },
        i
      );
    });
  } else if (isTweenWithTarget) {
    const target = tween.target;
    if (Array.isArray(target)) {
      return target.map((target2, i) => {
        const currTween = timeline[i];
        if (!currTween) {
          return null;
        }
        if (tween.to) {
          return (0, import_jsx_runtime.jsx)(
            Animation,
            {
              tween: __spreadProps(__spreadValues({}, tween), {
                target: target2,
                start: currTween.start,
                end: currTween.end,
                to: __spreadProps(__spreadValues({}, tween.to), {
                  onUpdateParams: [i]
                })
              }),
              disabled
            },
            i
          );
        } else if (tween.from) {
          return (0, import_jsx_runtime.jsx)(
            Animation,
            {
              tween: __spreadProps(__spreadValues({}, tween), {
                target: target2,
                start: currTween.start,
                end: currTween.end,
                from: __spreadProps(__spreadValues({}, tween.from), { onUpdateParams: [i] })
              }),
              disabled
            },
            i
          );
        } else if (tween.fromTo) {
          return (0, import_jsx_runtime.jsx)(
            Animation,
            {
              tween: __spreadProps(__spreadValues({}, tween), {
                target: target2,
                start: currTween.start,
                end: currTween.end,
                fromTo: [
                  __spreadValues({}, tween.fromTo[0]),
                  __spreadProps(__spreadValues({}, tween.fromTo[1]), {
                    onUpdateParams: [i]
                  })
                ]
              }),
              disabled
            },
            i
          );
        }
      });
    } else if (isDev) {
      throw new Error("Stagger target must be an array");
    }
  }
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {});
}
var overlapDurationArrayByFactor = (durations, factor) => {
  const first = durations[0];
  const last = durations[durations.length - 1];
  if (first === void 0 || last === void 0) {
    throw Error("Durations array is empty");
  }
  const veryStart = first.start;
  const veryEnd = last.end;
  const totalDuration = veryEnd - veryStart;
  const overlapDuration = totalDuration * factor;
  const overlapDurationPerDuration = overlapDuration / durations.length;
  const afterOverlapDuration = totalDuration - overlapDurationPerDuration * (durations.length - 1);
  const afterOverlapDurationDiffFactor = totalDuration / afterOverlapDuration;
  const newDurations = durations.map((duration, i) => {
    const newStart = duration.start - overlapDurationPerDuration * i;
    const newEnd = duration.end - overlapDurationPerDuration * i;
    return {
      start: Math.max(
        veryStart + (newStart - veryStart) * afterOverlapDurationDiffFactor,
        0
      ),
      end: Math.min(
        veryStart + (newEnd - veryStart) * afterOverlapDurationDiffFactor,
        100
      )
    };
  });
  return newDurations;
};
var getStaggeredTimeline = (config) => {
  const { start, end, overlap = 0, chunks = 1 } = config;
  if (overlap > 1 || overlap < 0) {
    throw new Error("Overlap must be between 0 and 1");
  }
  const duration = end - start;
  const chunkDuration = duration / chunks;
  const animationChunks = Array.from({ length: chunks }).map((_, i) => {
    const chunkStart = start + chunkDuration * i;
    const chunkEnd = chunkStart + chunkDuration;
    return {
      start: chunkStart,
      end: chunkEnd
    };
  });
  if (overlap > 0) {
    return overlapDurationArrayByFactor(animationChunks, overlap);
  }
  return animationChunks;
};
var useScrollToLabel = (label, opts) => {
  const scrollytelling = useScrollytelling();
  return React7.useCallback(() => {
    var _a;
    if (!scrollytelling.timeline)
      throw new Error("timeline not initialized");
    const st = scrollytelling.timeline.scrollTrigger;
    if (!st)
      throw new Error("scrollTrigger not found");
    const foundLabel = scrollytelling.timeline.labels[label];
    if (!foundLabel)
      throw new Error(`label ${label} not found`);
    const targetPx = st.labelToScroll(label);
    window.scrollTo({
      top: targetPx + ((_a = opts == null ? void 0 : opts.offset) != null ? _a : 0),
      behavior: opts == null ? void 0 : opts.behavior
    });
  }, [label, opts == null ? void 0 : opts.behavior, opts == null ? void 0 : opts.offset, scrollytelling.timeline]);
};
var Debugger = React7.lazy(() => import("./debugger-Z3ISUZF3-WAL7U2CF.js"));
var Scrollytelling = ({
  children,
  debug,
  start,
  end,
  callbacks,
  scrub,
  defaults,
  toggleActions,
  disabled = false,
  trigger
}) => {
  var _a;
  const explicitTriggerMode = trigger !== void 0;
  const ref = React7.useRef(null);
  const scopedQuerySelector = gsapWithCSS.utils.selector(ref);
  const id = React7.useId();
  const [timeline, setTimeline] = React7.useState();
  const debugMarkers = debug ? debug.markers : false;
  const debugVisualizer = debug ? (_a = debug.visualizer) != null ? _a : true : false;
  const debugLabel = debug ? debug.label : void 0;
  React7.useEffect(() => {
    if (!explicitTriggerMode && !ref.current)
      return;
    if (disabled) {
      setTimeline(void 0);
      return;
    }
    gsapWithCSS.registerPlugin(ScrollTrigger);
    const defaultToggleActions = scrub === false ? "play none none none" : void 0;
    const tl = gsapWithCSS.timeline({
      scrollTrigger: __spreadValues({
        markers: debugMarkers,
        scrub: scrub != null ? scrub : true,
        start: start != null ? start : "top top",
        end: end != null ? end : "bottom bottom",
        trigger: explicitTriggerMode ? trigger : ref.current,
        toggleActions: toggleActions != null ? toggleActions : defaultToggleActions
      }, callbacks),
      paused: true,
      defaults: __spreadProps(__spreadValues({}, defaults), { duration: 1 }),
      data: {
        id,
        type: "root",
        label: debugLabel != null ? debugLabel : id,
        debug: debugVisualizer,
        isScrollytellingTween: true
      }
    });
    tl.eventCallback("onUpdate", () => {
      internalEventEmmiter.emit("timeline:update", tl);
    });
    setTimeline(tl);
    return () => {
      tl.revert();
    };
  }, [
    debugLabel,
    explicitTriggerMode,
    end,
    start,
    callbacks,
    scrub,
    defaults,
    toggleActions,
    disabled,
    trigger,
    id,
    debugMarkers,
    debugVisualizer
  ]);
  const addRestToTimeline = React7.useCallback(
    (lastEnd, timeline2) => {
      var _a2;
      const restTweenId = `rest-${id}`;
      (_a2 = gsapWithCSS.getById(restTweenId)) == null ? void 0 : _a2.revert();
      const duration = 100 - lastEnd;
      const position = 100 - duration;
      timeline2.to(
        {},
        {
          id: restTweenId,
          duration,
          data: { type: "rest", id: restTweenId, rootId: id }
        },
        position
      );
      return () => {
        var _a3;
        (_a3 = gsapWithCSS.getById(restTweenId)) == null ? void 0 : _a3.revert();
      };
    },
    [id]
  );
  const getTimelineSpace = React7.useCallback(
    ({ start: start2, end: end2 }) => {
      if (disabled)
        return null;
      if (!timeline)
        throw new Error("timeline not initialized");
      const duration = end2 - start2;
      if (start2 < 0) {
        throw new Error("start time must be greater than 0");
      }
      if (end2 > 100) {
        throw new Error("end time must be less than 100");
      }
      if (duration < 0) {
        throw new Error("end time must be greater than start time");
      }
      const cleanup = addRestToTimeline(end2, timeline);
      internalEventEmmiter.emit("timeline:refresh", timeline);
      return {
        duration,
        position: start2,
        cleanup: () => {
          cleanup();
        }
      };
    },
    [disabled, timeline, addRestToTimeline]
  );
  return (0, import_jsx_runtime.jsx)(
    ScrollytellingContext.Provider,
    {
      value: { timeline, rootRef: ref, events: internalEventEmmiter },
      children: (0, import_jsx_runtime.jsxs)(
        ScrollytellingDispatchersContext.Provider,
        {
          value: { getTimelineSpace, scopedQuerySelector },
          children: [
            explicitTriggerMode ? children : (0, import_jsx_runtime.jsx)(Slot, { ref, children }),
            debug && (0, import_jsx_runtime.jsx)(React7.Suspense, { fallback: null, children: (0, import_jsx_runtime.jsx)(Debugger, {}) })
          ]
        }
      )
    }
  );
};
function mergeRefs(refs) {
  return (value) => {
    refs.forEach((ref) => {
      if (typeof ref === "function") {
        ref(value);
      } else if (ref != null) {
        ref.current = value;
      }
    });
  };
}
var ImageSequenceCanvas = React7.forwardRef((_a, ref) => {
  var _b = _a, { controllerRef, getFrameSrc } = _b, rest = __objRest(_b, ["controllerRef", "getFrameSrc"]);
  const canvasRef = React7.useRef(null);
  const supportTableRef = React7.useRef({
    supportsAvif: false,
    supportsWebp: false
  });
  const supportTablePromiseRef = React7.useRef(null);
  React7.useEffect(() => {
    supportTablePromiseRef.current = Promise.all([
      webpIsSupported(),
      avifIsSupported()
    ]).then(([supportsWebp, supportsAvif]) => {
      supportTableRef.current = { supportsWebp, supportsAvif };
    });
  }, []);
  React7.useImperativeHandle(
    controllerRef,
    () => {
      return {
        preload: (frameStart, frameEnd) => __async(void 0, null, function* () {
          yield supportTablePromiseRef.current;
          const promises = [];
          for (let frame = frameStart; frame <= frameEnd; frame++) {
            const src = getFrameSrc(frame, supportTableRef.current);
            promises.push(loadImage(src));
          }
          yield Promise.all(promises);
        }),
        draw: (frame) => __async(void 0, null, function* () {
          yield supportTablePromiseRef.current;
          const src = getFrameSrc(frame, supportTableRef.current);
          const canvas = canvasRef.current;
          const context = canvas == null ? void 0 : canvas.getContext("2d");
          if (!canvas || !context || !src)
            return;
          const img = yield loadImage(src);
          context.mozImageSmoothingEnabled = false;
          context.webkitImageSmoothingEnabled = false;
          context.msImageSmoothingEnabled = false;
          context.imageSmoothingEnabled = false;
          context.clearRect(0, 0, canvas.width, canvas.height);
          context.drawImage(img, 0, 0, canvas.width, canvas.height);
        }),
        get canvas() {
          return canvasRef.current;
        }
      };
    },
    [getFrameSrc]
  );
  return (0, import_jsx_runtime.jsx)("canvas", __spreadProps(__spreadValues({}, rest), { ref: mergeRefs([canvasRef, ref]) }));
});
ImageSequenceCanvas.displayName = "Scrollytelling.ImageSequenceCanvas";
var imagesLoadedCache = /* @__PURE__ */ new Map();
function loadImage(src) {
  return new Promise((resolve, reject) => {
    const imageFromCache = imagesLoadedCache.get(src);
    if (imageFromCache) {
      if (imageFromCache.complete) {
        resolve(imageFromCache);
      } else {
        imageFromCache.addEventListener("load", () => resolve(imageFromCache), {
          once: true
        });
      }
    } else {
      const image = new Image();
      image.addEventListener("load", () => resolve(image), { once: true });
      image.onerror = () => reject(new Error(`Failed to load image: ${src}`));
      image.src = src;
      imagesLoadedCache.set(src, image);
    }
  });
}
function webpIsSupported() {
  return __async(this, null, function* () {
    if (!window.createImageBitmap)
      return false;
    const webpData = "data:image/webp;base64,UklGRiQAAABXRUJQVlA4IBgAAAAwAQCdASoCAAEAAQAcJaQAA3AA/v3AgAA=";
    const blob = yield fetch(webpData).then((r) => r.blob());
    return createImageBitmap(blob).then(
      () => true,
      () => false
    );
  });
}
function avifIsSupported() {
  return __async(this, null, function* () {
    if (!window.createImageBitmap)
      return false;
    const avifData = "data:image/avif;base64,UklGRiQAAABXRUJQVlA4IBgAAAAwAQCdASoCAAEAAQAcJaQAA3AA/v3AgAA=";
    const blob = yield fetch(avifData).then((r) => r.blob());
    return createImageBitmap(blob).then(
      () => true,
      () => false
    );
  });
}
export {
  Animation,
  ImageSequenceCanvas,
  Parallax,
  Pin,
  RegisterGsapPlugins,
  Scrollytelling as Root,
  Stagger,
  Waypoint,
  useScrollToLabel,
  useScrollytelling
};
//# sourceMappingURL=@bsmnt_scrollytelling.js.map
